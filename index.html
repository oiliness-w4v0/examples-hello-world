<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebAR é«˜çº§æ‰‹åŠ¿äº¤äº’</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: sans-serif; }
        
        #container { position: relative; width: 100vw; height: 100vh; overflow: hidden; }

        /* 
           å…³é”®ç‚¹ï¼šåªç¿»è½¬è§†é¢‘èƒŒæ™¯ï¼Œä¿æŒ Three.js ç”»å¸ƒæ­£å¸¸ 
           è¿™æ ·å…‰ç…§å’Œç‰©ç†æ–¹å‘æ‰ä¸ä¼šä¹±
        */
        video {
            position: absolute;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1); 
            opacity: 0.6; /* è®©è§†é¢‘ç¨å¾®æš—ä¸€ç‚¹ï¼Œçªå‡ºæ¨¡å‹ */
        }

        #three-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 2;
        }

        #ui-layer {
            position: absolute;
            top: 20px; width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }
        
        .status-badge {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 10px 24px;
            border-radius: 50px;
            font-size: 16px;
            border: 1px solid rgba(255,255,255,0.3);
            display: inline-block;
            transition: all 0.3s;
        }

        .tips {
            color: rgba(255,255,255,0.8);
            font-size: 12px;
            margin-top: 8px;
            text-shadow: 0 1px 2px black;
        }

        #debug {
            position: absolute;
            bottom: 10px; left: 10px;
            color: #555;
            font-size: 10px;
        }
    </style>
</head>
<body>

<div id="container">
    <video id="input_video" playsinline></video>
    <canvas id="three-canvas"></canvas>
    
    <div id="ui-layer">
        <div id="status-box" class="status-badge">â³ æ¨¡å‹åŠ è½½ä¸­...</div>
        <div class="tips">æåˆä¸¤æŒ‡æ‹–æ‹½ Â· æ‰‹æŒé è¿‘æ‹‰è¿‘</div>
    </div>
    <div id="debug">Debug info</div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // === é…ç½®å‚æ•° ===
    const CONFIG = {
        cameraZ: 6,           // Threejs ç›¸æœºè·ç¦»
        smoothFactor: 0.15,   // å¹³æ»‘ç³»æ•° (0.01-1.0)ï¼Œè¶Šå°è¶Šç¨³ä½†å»¶è¿Ÿè¶Šé«˜ï¼Œå»ºè®® 0.1-0.2
        moveSpeed: 10,        // ç§»åŠ¨çµæ•åº¦
        depthScale: 15,       // æ·±åº¦ç¼©æ”¾çµæ•åº¦
        pinchThreshold: 0.06, // æåˆé˜ˆå€¼
    };

    // DOM å…ƒç´ 
    const videoElement = document.getElementById('input_video');
    const threeCanvas = document.getElementById('three-canvas');
    const statusBox = document.getElementById('status-box');
    const debugText = document.getElementById('debug');

    // Three.js å˜é‡
    let scene, camera, renderer, model;
    let targetPos = new THREE.Vector3(0, 0, 0); // ç›®æ ‡ä½ç½®
    let currentPos = new THREE.Vector3(0, 0, 0); // å½“å‰å¹³æ»‘åçš„ä½ç½®
    
    // äº¤äº’çŠ¶æ€
    let isPinching = false;
    let isHandDetected = false;

    // === å¹³æ»‘å¤„ç†ç±» ===
    class Smoother {
        constructor(initialValue, alpha) {
            this.value = initialValue;
            this.alpha = alpha;
        }
        update(newValue) {
            // ç®€å•çš„ä½é€šæ»¤æ³¢å™¨ (EMA)
            this.value = this.value * (1 - this.alpha) + newValue * this.alpha;
            return this.value;
        }
    }
    
    // åˆ†åˆ«å¹³æ»‘ X, Y, Z
    const smoothX = new Smoother(0, CONFIG.smoothFactor);
    const smoothY = new Smoother(0, CONFIG.smoothFactor);
    const smoothZ = new Smoother(0, CONFIG.smoothFactor);


    // === 1. åˆå§‹åŒ– Three.js ===
    function initThree() {
        scene = new THREE.Scene();
        // å¢åŠ ç¯å¢ƒå…‰ï¼Œé˜²æ­¢æ¨¡å‹å¤ªé»‘
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // ä½¿ç”¨é€è§†ç›¸æœº
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = CONFIG.cameraZ;

        renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶åƒç´ æ¯”ä»¥ä¼˜åŒ–æ€§èƒ½

        // åŠ è½½æ¨¡å‹
        const loader = new GLTFLoader();
        // ä½¿ç”¨ä¸€ä¸ªæ›´æœ‰è´¨æ„Ÿçš„ 3D æ¨¡å‹
        const modelUrl = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb';
        
        loader.load(modelUrl, (gltf) => {
            model = gltf.scene;
            // åˆå§‹åŒ–å¤§å°å’Œä½ç½®
            model.scale.set(1.5, 1.5, 1.5);
            model.rotation.y = 0.5;
            scene.add(model);
            
            statusBox.innerText = "ğŸ– è¯·å°†æ‰‹æ”¾å…¥æ‘„åƒå¤´èŒƒå›´";
            statusBox.style.backgroundColor = "rgba(0,0,0,0.6)";
            
            animate();
        }, undefined, (err) => {
            statusBox.innerText = "æ¨¡å‹åŠ è½½å¤±è´¥";
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // === 2. æ¸²æŸ“å¾ªç¯ ===
    function animate() {
        requestAnimationFrame(animate);

        if (model) {
            // å¦‚æœæ­£åœ¨æåˆï¼Œæ›´æ–°ç›®æ ‡ä½ç½®
            if (isPinching) {
                // è®¡ç®—å½“å‰å¸§çš„å¹³æ»‘åæ ‡
                const smX = smoothX.value;
                const smY = smoothY.value;
                const smZ = smoothZ.value;

                // è®¾ç½®æ¨¡å‹ä½ç½®
                model.position.set(smX, smY, smZ);
                
                // å¢åŠ ä¸€ç‚¹åŠ¨æ€æ—‹è½¬ï¼Œæ ¹æ®ç§»åŠ¨æ–¹å‘å€¾æ–œæ¨¡å‹
                model.rotation.x += (smY - model.rotation.x) * 0.05;
                model.rotation.y += (smX - model.rotation.y) * 0.05;
                
                statusBox.innerText = "âœŠ æ‹–åŠ¨ä¸­...";
                statusBox.style.color = "#FFD700"; // é‡‘è‰²
                statusBox.style.borderColor = "#FFD700";
            } else {
                // å¦‚æœæ¾å¼€ï¼Œè®©æ¨¡å‹ç¼“æ…¢å›æ­£æˆ–æ‚¬æµ®
                model.rotation.x *= 0.95;
                model.rotation.y *= 0.95;
                
                if (isHandDetected) {
                    statusBox.innerText = "ğŸ– å‡†å¤‡å°±ç»ª (è¯·æåˆ)";
                    statusBox.style.color = "#fff";
                    statusBox.style.borderColor = "rgba(255,255,255,0.3)";
                } else {
                    statusBox.innerText = "æœªæ£€æµ‹åˆ°æ‰‹éƒ¨";
                    statusBox.style.color = "#ccc";
                }
            }
        }
        renderer.render(scene, camera);
    }

    initThree();

    // === 3. MediaPipe é€»è¾‘ ===
    function onResults(results) {
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
            isHandDetected = false;
            return;
        }

        isHandDetected = true;
        const landmarks = results.multiHandLandmarks[0];

        // å…³é”®ç‚¹è·å–
        const thumb = landmarks[4];  // æ‹‡æŒ‡å°–
        const index = landmarks[8];  // é£ŸæŒ‡å°–
        const wrist = landmarks[0];  // æ‰‹è…•
        const middleBase = landmarks[9]; // ä¸­æŒ‡æ ¹éƒ¨ (ç”¨äºè®¡ç®—æ‰‹æŒå¤§å°)

        // --- 1. è®¡ç®—æåˆ ---
        // ä½¿ç”¨æ¬§å‡ é‡Œå¾—è·ç¦»
        const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
        
        // --- 2. è®¡ç®—æ‰‹æŒå¤§å° (ç”¨äºæ¨¡æ‹Ÿ Z è½´æ·±åº¦) ---
        // æ‰‹è…•åˆ°ä¸­æŒ‡æ ¹éƒ¨çš„è·ç¦»æ˜¯ç›¸å¯¹å›ºå®šçš„éª¨éª¼è·ç¦»ï¼Œé€‚åˆåšå‚ç…§
        const handSize = Math.hypot(wrist.x - middleBase.x, wrist.y - middleBase.y);

        // åˆ¤æ–­æ˜¯å¦æåˆ
        if (pinchDist < CONFIG.pinchThreshold) {
            isPinching = true;

            // --- 3. æ ¸å¿ƒï¼šåæ ‡æ˜ å°„ç®—æ³• (è§£å†³æ–¹å‘åã€æ‹‰è¿‘æ‹‰è¿œ) ---
            
            // Xè½´æ˜ å°„ï¼š
            // MediaPipe: [0(å·¦), 1(å³)]ã€‚
            // é•œåƒè§†é¢‘åï¼šç”¨æˆ·å‘å³ç§»ï¼Œç”»é¢ä¸­æ‰‹å‘å³ç§»(xå˜å¤§)ã€‚
            // Threejs: [è´Ÿ(å·¦), æ­£(å³)]ã€‚
            // ç®—æ³•ï¼š(x - 0.5) * èŒƒå›´
            let targetX = (index.x - 0.5) * CONFIG.moveSpeed;
            // å¦‚æœå‘ç°æ–¹å‘åäº†ï¼ŒæŠŠä¸Šé¢çš„ index.x æ”¹ä¸º (1 - index.x) å³å¯ã€‚
            // åœ¨ scaleX(-1) çš„è§†é¢‘èƒŒæ™¯ä¸‹ï¼Œé€šå¸¸éœ€è¦åè½¬ X è¾“å…¥æ¥åŒ¹é…è§†è§‰
            targetX = (1 - index.x - 0.5) * CONFIG.moveSpeed; 

            // Yè½´æ˜ å°„ï¼š
            // MediaPipe: [0(ä¸Š), 1(ä¸‹)]
            // Threejs: [æ­£(ä¸Š), è´Ÿ(ä¸‹)]
            // ç®—æ³•ï¼š(0.5 - y) * èŒƒå›´
            let targetY = (0.5 - index.y) * (CONFIG.moveSpeed * 0.6); // Yè½´èŒƒå›´ç¨å°ä¸€ç‚¹

            // Zè½´æ˜ å°„ (æ‹‰è¿‘æ‹‰è¿œ)ï¼š
            // handSize è¶Šå¤§ï¼Œè¯´æ˜æ‰‹ç¦»æ‘„åƒå¤´è¶Šè¿‘ï¼ŒZ åº”è¯¥è¶Šå¤§ (æ¥è¿‘ç›¸æœº)
            // åŸºå‡† handSize å¤§çº¦æ˜¯ 0.15 (è¿œ) åˆ° 0.4 (è¿‘)
            // æ˜ å°„åˆ° Z è½´: -2 (è¿œ) åˆ° 2 (è¿‘)
            let targetZ = (handSize - 0.2) * CONFIG.depthScale;

            // --- 4. è¾“å…¥å¹³æ»‘å™¨ ---
            smoothX.update(targetX);
            smoothY.update(targetY);
            smoothZ.update(targetZ);

            debugText.innerText = `Z-Depth: ${targetZ.toFixed(2)} | Size: ${handSize.toFixed(3)}`;
        } else {
            isPinching = false;
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 1280, height: 720, facingMode: "user"
    });
    cameraUtils.start();

</script>
</body>
</html>