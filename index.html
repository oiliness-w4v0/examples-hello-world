<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>è™šæ‹Ÿç©ºé—´å±•ç¤º - æ— æ ‡è®°ç‰ˆ</title>

    <!-- 1. Three.js æ ¸å¿ƒ -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <!-- 2. MediaPipe (ç”¨äºæ‰‹åŠ¿) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        
        /* è§†é¢‘èƒŒæ™¯å±‚ */
        #bg-video {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; z-index: 0;
            /* åç½®æ‘„åƒå¤´ä¸éœ€è¦é•œåƒï¼Œå¦‚æœæ˜¯å‰ç½®éœ€è¦ scaleX(-1) */
        }

        /* 3D æ¸²æŸ“å±‚ */
        #three-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€ */
        }

        /* å¯åŠ¨/æƒé™å±‚ */
        #start-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center; color: white;
        }
        #enter-btn {
            margin-top: 20px; padding: 12px 30px; border-radius: 30px;
            background: #00ff88; color: #000; font-weight: bold; border: none; font-size: 16px;
        }
        
        /* çŠ¶æ€æç¤º */
        #status-bar {
            position: fixed; top: 20px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.8); z-index: 100; font-size: 14px;
            text-shadow: 1px 1px 2px black; pointer-events: none;
        }
        
        /* Canvas ä¸­è½¬ (å®‰å“å…¼å®¹) */
        #input-canvas { display: none; }
    </style>
</head>
<body>

    <!-- å¯åŠ¨å±‚ -->
    <div id="start-layer">
        <h2>ğŸ›ï¸ æ²‰æµ¸å¼å±•å°</h2>
        <p style="opacity: 0.7; font-size: 14px; padding: 0 20px; text-align: center;">
            æ— éœ€æ‰«æï¼Œç‚¹å‡»æŒ‰é’®å³å¯åœ¨ç©ºé—´ä¸­çœ‹åˆ°æ–‡ç‰©
        </p>
        <button id="enter-btn">å¼€å¯ç©ºé—´ (è·å–æƒé™)</button>
    </div>

    <div id="status-bar">å‡†å¤‡ä¸­...</div>

    <!-- æ ¸å¿ƒå…ƒç´  -->
    <video id="bg-video" playsinline webkit-playsinline muted autoplay></video>
    <canvas id="input-canvas"></canvas>
    <canvas id="three-canvas"></canvas>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DeviceOrientationControls } from 'three/addons/controls/DeviceOrientationControls.js';

    // === é…ç½® ===
    const CONFIG = {
        distance: 2.5,  // æ¨¡å‹è·ç¦»æ‘„åƒå¤´çš„è·ç¦» (ç±³)
        scale: 0.8,     // æ¨¡å‹åˆå§‹å¤§å°
        fps: 15         // æ‰‹åŠ¿è¯†åˆ«å¸§ç‡ (çœç”µ)
    };

    // DOM
    const videoEl = document.getElementById('bg-video');
    const inputCanvas = document.getElementById('input-canvas');
    const ctx = inputCanvas.getContext('2d');
    const statusBar = document.getElementById('status-bar');
    const startLayer = document.getElementById('start-layer');
    const enterBtn = document.getElementById('enter-btn');

    // 3D å˜é‡
    let scene, camera, renderer, model, controls;
    let isRunning = false;

    // æ‰‹åŠ¿å˜é‡
    let isPinching = false;
    let startPinch = { x: 0, y: 0 };
    let initialTransform = { scale: 1, rotY: 0 };
    let targetTransform = { scale: CONFIG.scale, rotY: 0 };
    let currentTransform = { scale: CONFIG.scale, rotY: 0 };

    // === 1. æƒé™ä¸å¯åŠ¨æµç¨‹ ===
    enterBtn.addEventListener('click', async () => {
        try {
            // iOS 13+ éœ€è¦è¯·æ±‚ DeviceOrientation æƒé™
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                const response = await DeviceOrientationEvent.requestPermission();
                if (response !== 'granted') {
                    alert("éœ€è¦ä¼ æ„Ÿå™¨æƒé™æ‰èƒ½ä½“éªŒç©ºé—´æ•ˆæœ");
                    return;
                }
            }
            
            startLayer.style.display = 'none';
            statusBar.innerText = "æ­£åœ¨åˆå§‹åŒ–ç©ºé—´...";
            
            // å¯åŠ¨æ‘„åƒå¤´
            await startCamera();
            // åˆå§‹åŒ– 3D
            initThree();
            // åˆå§‹åŒ– AI
            initAI();
            
            isRunning = true;
            
        } catch (e) {
            console.error(e);
            alert("å¯åŠ¨å¤±è´¥: " + e.message);
        }
    });

    // === 2. æ‘„åƒå¤´é€»è¾‘ (åç½®) ===
    async function startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'environment', // åç½®
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            });
            videoEl.srcObject = stream;
            return new Promise(resolve => {
                videoEl.onloadedmetadata = () => {
                    videoEl.play();
                    resolve();
                };
            });
        } catch (err) {
            alert("æ— æ³•è°ƒç”¨æ‘„åƒå¤´ï¼Œè¯·ç¡®ä¿åœ¨ HTTPS ç¯å¢ƒä¸‹");
            throw err;
        }
    }

    // === 3. Three.js åœºæ™¯æ„å»º ===
    function initThree() {
        // åœºæ™¯
        scene = new THREE.Scene();
        // å…‰ç…§
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
        dirLight.position.set(0, 5, 5);
        scene.add(ambientLight);
        scene.add(dirLight);

        // ç›¸æœº
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
        
        // ã€å…³é”®ã€‘ä½¿ç”¨ DeviceOrientationControls
        // è¿™ä¼šè®© Three.js çš„ç›¸æœºè·Ÿéšæ‰‹æœºè½¬åŠ¨
        controls = new DeviceOrientationControls(camera);

        // æ¸²æŸ“å™¨
        renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('three-canvas'),
            alpha: true, // é€æ˜èƒŒæ™¯ï¼Œä¸ºäº†é€å‡ºä¸‹é¢çš„ video
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // åŠ è½½æ¨¡å‹
        const loader = new GLTFLoader();
        // æ›¿æ¢ä¸ºä½ çš„ GLB æ¨¡å‹åœ°å€
        const modelUrl = './DamagedHelmet.glb';
        
        loader.load(modelUrl, (gltf) => {
            model = gltf.scene;
            
            // åˆå§‹ä½ç½®è®¾ç½®åœ¨ï¼šæ­£å‰æ–¹ (Zè´Ÿè½´)
            // æ³¨æ„ï¼šæˆ‘ä»¬æŠŠæ¨¡å‹æ”¾è¿›ä¸€ä¸ª Group é‡Œï¼Œæ–¹ä¾¿æ—‹è½¬
            model.position.set(0, 0, -CONFIG.distance); 
            
            scene.add(model);
            statusBar.innerText = "æ–‡ç‰©å·²æ‚¬æµ®ï¼Œè½¬èº«çœ‹çœ‹";
            animate();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    // æ¸²æŸ“å¾ªç¯
    function animate() {
        requestAnimationFrame(animate);
        
        // æ›´æ–°ç›¸æœºæ§åˆ¶ (é™€èºä»ª)
        controls.update();

        if (model) {
            // å¹³æ»‘å¤„ç†æ‰‹åŠ¿äº¤äº’
            // ç¼©æ”¾
            currentTransform.scale += (targetTransform.scale - currentTransform.scale) * 0.1;
            model.scale.set(currentTransform.scale, currentTransform.scale, currentTransform.scale);
            
            // æ—‹è½¬ (è¿™é‡Œæˆ‘ä»¬æ—‹è½¬æ¨¡å‹æœ¬èº«ï¼Œè€Œä¸æ˜¯ç›¸æœº)
            currentTransform.rotY += (targetTransform.rotY - currentTransform.rotY) * 0.1;
            model.rotation.y = currentTransform.rotY;
        }

        renderer.render(scene, camera);
    }

    // === 4. æ‰‹åŠ¿ AI é€»è¾‘ ===
    function initAI() {
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // æ€§èƒ½ä¼˜å…ˆ
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onHandResults);

        // èŠ‚æµæ£€æµ‹å¾ªç¯
        let lastTime = 0;
        const interval = 1000 / CONFIG.fps;

        async function aiLoop(time) {
            if (!isRunning) return;
            
            if (time - lastTime >= interval && videoEl.videoWidth > 0) {
                lastTime = time;
                // ä¸­è½¬ Canvasï¼Œé˜²æ­¢å®‰å“é»‘å±
                if (inputCanvas.width !== videoEl.videoWidth) {
                    inputCanvas.width = videoEl.videoWidth;
                    inputCanvas.height = videoEl.videoHeight;
                }
                ctx.drawImage(videoEl, 0, 0);
                
                try {
                    await hands.send({image: inputCanvas});
                } catch (e) {}
            }
            requestAnimationFrame(aiLoop);
        }
        aiLoop(0);
    }

    // æ‰‹åŠ¿å¤„ç†
    function onHandResults(results) {
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
            isPinching = false;
            return;
        }

        const lm = results.multiHandLandmarks[0];
        const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y); // æ‹‡æŒ‡ä¸é£ŸæŒ‡è·ç¦»

        if (dist < 0.08) {
            // æåˆä¸­
            if (!isPinching) {
                isPinching = true;
                startPinch = { x: lm[8].x, y: lm[8].y };
                initialTransform = { ...targetTransform };
                statusBar.innerText = "âœŠ äº¤äº’ä¸­ï¼šä¸Šä¸‹ç¼©æ”¾ / å·¦å³æ—‹è½¬";
                statusBar.style.color = "#FFD700";
            } else {
                // è®¡ç®—ç§»åŠ¨é‡
                const deltaX = lm[8].x - startPinch.x;
                const deltaY = startPinch.y - lm[8].y; // ä¸Šä¸ºæ­£

                // æ§åˆ¶
                targetTransform.rotY = initialTransform.rotY + (deltaX * 3);
                targetTransform.scale = Math.max(0.1, Math.min(3, initialTransform.scale + (deltaY * 2)));
            }
        } else {
            if (isPinching) {
                isPinching = false;
                statusBar.innerText = "ğŸ– æ¾å¼€ä»¥å›ºå®š";
                statusBar.style.color = "#fff";
            }
        }
    }
</script>
</body>
</html>