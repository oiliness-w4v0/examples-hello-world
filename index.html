<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>H5 æ‰‹åŠ¿æ§åˆ¶ 3D æ¨¡å‹</title>
    
    <!-- å¼•å…¥ MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- å¼•å…¥ Three.js (é€šè¿‡ Import Map æ–¹å¼å¼•å…¥ ES Module) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        
        #container { position: relative; width: 100vw; height: 100vh; }

        /* è§†é¢‘éšè—ï¼Œä»…ç”¨äºé‡‡é›† */
        video { display: none; }

        /* 3D åœºæ™¯å±‚ (æœ€åº•å±‚) */
        #three-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
            /* é•œåƒç¿»è½¬ï¼Œè®©æ“ä½œæ›´ç¬¦åˆç›´è§‰ */
            transform: scaleX(-1); 
        }

        /* æ‰‹åŠ¿éª¨éª¼ç»˜åˆ¶å±‚ (ç”¨äºè°ƒè¯•ï¼Œå¯é€‰) */
        #skeleton-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 2;
            transform: scaleX(-1);
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€ */
        }

        /* UI æç¤º */
        #info {
            position: absolute;
            top: 20px; left: 50%;
            transform: translateX(-50%);
            z-index: 3;
            color: white;
            text-align: center;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 20px;
            pointer-events: none;
        }
        .highlight { color: #00ff88; font-weight: bold; font-size: 1.2em; }
    </style>
</head>
<body>

<div id="container">
    <video id="input_video" playsinline></video>
    <!-- Three.js æ¸²æŸ“å±‚ -->
    <canvas id="three-canvas"></canvas>
    <!-- MediaPipe éª¨éª¼è°ƒè¯•å±‚ -->
    <canvas id="skeleton-canvas"></canvas>

    <div id="info">
        <div id="loading-text">æ­£åœ¨åŠ è½½æ¨¡å‹å’ŒAI...</div>
        <div id="status-text" style="display:none;">
            çŠ¶æ€: <span id="gesture-name" class="highlight">ç­‰å¾…æ‰‹åŠ¿</span>
            <br><small>æåˆé£ŸæŒ‡æ‹‡æŒ‡æ¥æ‹–åŠ¨æ¨¡å‹</small>
        </div>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // === 1. å˜é‡å®šä¹‰ ===
    const videoElement = document.getElementById('input_video');
    const skeletonCanvas = document.getElementById('skeleton-canvas');
    const skeletonCtx = skeletonCanvas.getContext('2d');
    const threeCanvas = document.getElementById('three-canvas');
    
    // UI å…ƒç´ 
    const statusText = document.getElementById('status-text');
    const loadingText = document.getElementById('loading-text');
    const gestureNameDiv = document.getElementById('gesture-name');

    // Three.js æ ¸å¿ƒå˜é‡
    let scene, camera, renderer, model;
    let targetPosition = new THREE.Vector3(0, 0, 0); // ç›®æ ‡ä½ç½®
    let isPinching = false; // æ˜¯å¦åœ¨æåˆ

    // === 2. åˆå§‹åŒ– Three.js åœºæ™¯ ===
    function initThree() {
        scene = new THREE.Scene();
        // ç»™ä¸ªç®€å•çš„èƒŒæ™¯è‰²ï¼Œæˆ–è€…è®¾ä¸ºé€æ˜
        scene.background = new THREE.Color(0x222222); 

        // ç›¸æœºè®¾ç½®
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5; // ç›¸æœºåæ‹‰

        // ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(2, 5, 5);
        scene.add(dirLight);

        // æ¸²æŸ“å™¨
        renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // åŠ è½½ GLB æ¨¡å‹
        const loader = new GLTFLoader();
        // è¿™é‡Œä½¿ç”¨äº†ä¸€ä¸ªå…¬å¼€çš„ Robot æ¨¡å‹ï¼Œä½ å¯ä»¥æ¢æˆä½ è‡ªå·±çš„ .glb åœ°å€
        const modelUrl = 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/gltf/RobotExpressive/RobotExpressive.glb';
        
        loader.load(modelUrl, (gltf) => {
            model = gltf.scene;
            model.scale.set(0.5, 0.5, 0.5); // è°ƒæ•´æ¨¡å‹å¤§å°
            // å°†æ¨¡å‹ä½ç½®ä¸‹ç§»ä¸€ç‚¹ï¼Œå±…ä¸­
            model.position.y = -1; 
            scene.add(model);
            
            loadingText.style.display = 'none';
            statusText.style.display = 'block';
            
            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animateThree();
        }, undefined, (error) => {
            console.error(error);
            loadingText.innerText = "æ¨¡å‹åŠ è½½å¤±è´¥";
        });

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            skeletonCanvas.width = window.innerWidth;
            skeletonCanvas.height = window.innerHeight;
        });
        
        // åˆå§‹åŒ– Canvas å°ºå¯¸
        skeletonCanvas.width = window.innerWidth;
        skeletonCanvas.height = window.innerHeight;
    }

    // Three.js åŠ¨ç”»å¾ªç¯
    function animateThree() {
        requestAnimationFrame(animateThree);

        if (model) {
            // å¹³æ»‘ç§»åŠ¨é€»è¾‘ (Linear Interpolation)
            // å¦‚æœæ­£åœ¨æåˆï¼Œè®©æ¨¡å‹çš„ä½ç½®é€æ¸é è¿‘ç›®æ ‡ä½ç½®(æ‰‹çš„ä½ç½®)
            if (isPinching) {
                // lerp ç¬¬äºŒä¸ªå‚æ•° 0.1 æ§åˆ¶è·Ÿéšé€Ÿåº¦ï¼Œè¶Šå°è¶Šå¹³æ»‘ä½†æœ‰å»¶è¿Ÿ
                model.position.lerp(targetPosition, 0.1);
                
                // æåˆæ—¶ç¨å¾®æ—‹è½¬ä¸€ä¸‹ï¼Œå¢åŠ äº’åŠ¨æ„Ÿ
                model.rotation.y += 0.05;
                model.scale.lerp(new THREE.Vector3(0.4, 0.4, 0.4), 0.1); // å˜å°ä¸€ç‚¹è¡¨ç¤ºè¢«æä½
            } else {
                // æ¾å¼€æ—¶æ¢å¤åŸçŠ¶
                model.scale.lerp(new THREE.Vector3(0.5, 0.5, 0.5), 0.1);
                // ä¹Ÿå¯ä»¥æ·»åŠ ä¸€ä¸ªè‡ªåŠ¨å›å¼¹é€»è¾‘ï¼Œæˆ–è€…å°±ç•™åœ¨åŸåœ°
            }
        }

        renderer.render(scene, camera);
    }

    initThree();

    // === 3. MediaPipe æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ ===
    
    function onResults(results) {
        // æ¸…ç©º 2D ç”»å¸ƒ
        skeletonCtx.save();
        skeletonCtx.clearRect(0, 0, skeletonCanvas.width, skeletonCanvas.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            // åªå–ç¬¬ä¸€åªæ‰‹
            const landmarks = results.multiHandLandmarks[0];

            // ç»˜åˆ¶éª¨éª¼ (å¯é€‰ï¼Œæ–¹ä¾¿è°ƒè¯•)
            drawConnectors(skeletonCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(skeletonCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 3});

            // è·å–å…³é”®ç‚¹ï¼š4(æ‹‡æŒ‡å°–), 8(é£ŸæŒ‡å°–)
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];

            // 1. è®¡ç®—æåˆè·ç¦»
            const distance = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + 
                Math.pow(thumbTip.y - indexTip.y, 2)
            );

            // 2. çŠ¶æ€åˆ¤æ–­
            if (distance < 0.08) {
                if (!isPinching) {
                    gestureNameDiv.innerText = "âœŠ æåˆ (æ‹–åŠ¨ä¸­)";
                    gestureNameDiv.style.color = "#ffdd00";
                }
                isPinching = true;

                // 3. åæ ‡æ˜ å°„: å±å¹• 2D -> Three.js 3D
                // MediaPipe è¾“å‡º x:0~1, y:0~1
                // Three.js è§†å£èŒƒå›´å¤§çº¦æ˜¯ x:-width~width, y:-height~height (å–å†³äºç›¸æœºZè½´è·ç¦»)
                
                // ç®€å•çš„æ˜ å°„ç®—æ³• (åŸºäºç›¸æœº Z=5 çš„å¹³é¢)
                // è¿™é‡Œçš„ 6 å’Œ 3 æ˜¯æ ¹æ®ç›¸æœºè·ç¦»è¯•å‡ºæ¥çš„ç¼©æ”¾ç³»æ•°ï¼Œä¿è¯æ‰‹ç§»åŠ¨èƒ½è¦†ç›–å±å¹•
                // æ³¨æ„ï¼šMediaPipe çš„ x æ˜¯é•œåƒçš„ï¼Œä¸” 0 åœ¨å·¦è¾¹ï¼ŒThree.js 0 åœ¨ä¸­é—´
                
                const x = (0.5 - indexTip.x) * 8; // å·¦å³æ˜ å°„
                const y = (0.5 - indexTip.y) * 5; // ä¸Šä¸‹æ˜ å°„
                
                targetPosition.set(x, y, 0);

            } else {
                if (isPinching) {
                    gestureNameDiv.innerText = "ğŸ– å¼ å¼€ (åœæ­¢)";
                    gestureNameDiv.style.color = "#00ff88";
                }
                isPinching = false;
            }

        } else {
            gestureNameDiv.innerText = "æœªæ£€æµ‹åˆ°æ‰‹";
            gestureNameDiv.style.color = "#ccc";
            isPinching = false;
        }
        skeletonCtx.restore();
    }

    // åˆå§‹åŒ– MediaPipe
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    // å¯åŠ¨æ‘„åƒå¤´
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 1280,
        height: 720,
        facingMode: "user"
    });
    cameraUtils.start();

</script>
</body>
</html>